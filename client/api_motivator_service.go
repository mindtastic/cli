/*
Kopfsachen

Kopfsachen e. V. is an association for the promotion of young people's mental health. The goal is to teach the basics of mental health literacy in various educational formats.

API version: 1.0.2
Contact: mail@kopfsachen.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MotivatorServiceApiService MotivatorServiceApi service
type MotivatorServiceApiService service

type ApiMotivatorGetRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
}

func (r ApiMotivatorGetRequest) Execute() ([]Motivator, *http.Response, error) {
	return r.ApiService.MotivatorGetExecute(r)
}

/*
MotivatorGet Get motivators for authenticated user

This endpoint returns all motivators that should be available to the user in the frontend.

A *motivator* is a generic exercise, that displays different type of contexts and eventually offers input elements. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMotivatorGetRequest
*/
func (a *MotivatorServiceApiService) MotivatorGet(ctx context.Context) ApiMotivatorGetRequest {
	return ApiMotivatorGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Motivator
func (a *MotivatorServiceApiService) MotivatorGetExecute(r ApiMotivatorGetRequest) ([]Motivator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Motivator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMotivatorResultAddRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	motivatorId int32
	motivatorResult *MotivatorResult
}

// The result to submit on the motivator.   The &#x60;values&#x60; property acts as a dictionary, containing the IDs referenced in the &#x60;input&#x60; object in the motivator content.   The coressponding value, again is a dictionary of mapping the reference string to objects containing a single &#x60;value&#x60; property.   The type of &#x60;value&#x60; depends on the individual input type.
func (r ApiMotivatorResultAddRequest) MotivatorResult(motivatorResult MotivatorResult) ApiMotivatorResultAddRequest {
	r.motivatorResult = &motivatorResult
	return r
}

func (r ApiMotivatorResultAddRequest) Execute() (*MotivatorResultCreatedResponse, *http.Response, error) {
	return r.ApiService.MotivatorResultAddExecute(r)
}

/*
MotivatorResultAdd Add a new result to user's current motivator.

This endpoint submits a users result on a motivator exercise.

A result is basically an array of collected users inputs according to the motivator specification provided by the `GET /motivator` endpoint.

The user can also submit optional feedback on a motivator with a result response. As collection of free-text comments as part of an evaluation is very sensitive in terms of privacy, this version of the API does not include such an option.

On success, the endpoint returns a `201 Created` response, with the body containing the `id` of the motivator result and a new `state` for the motivator exercises, as a motivator could consist out of multiple parts. If the return value indicates that a motivator is not fully completed, you should call the `GET` endpoint again, as the content the motivator could have changed.

If the motivator does not exists or is not available for the current user, a `404 Not Found` response is returned.

If the validation of the request body against the specified schema fails, or does not match the actual inputs of the motivator, a `422 Unprocessable Entity` response is returned, with the body containing an `error` string with further information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param motivatorId The `id` of the motivator you want to add a result for.
 @return ApiMotivatorResultAddRequest
*/
func (a *MotivatorServiceApiService) MotivatorResultAdd(ctx context.Context, motivatorId int32) ApiMotivatorResultAddRequest {
	return ApiMotivatorResultAddRequest{
		ApiService: a,
		ctx: ctx,
		motivatorId: motivatorId,
	}
}

// Execute executes the request
//  @return MotivatorResultCreatedResponse
func (a *MotivatorServiceApiService) MotivatorResultAddExecute(r ApiMotivatorResultAddRequest) (*MotivatorResultCreatedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MotivatorResultCreatedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorResultAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator/{motivatorId}/result"
	localVarPath = strings.Replace(localVarPath, "{"+"motivatorId"+"}", url.PathEscape(parameterToString(r.motivatorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.motivatorResult
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MotivatorValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMotivatorResultDeleteAllRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	motivatorId int32
}

func (r ApiMotivatorResultDeleteAllRequest) Execute() (*http.Response, error) {
	return r.ApiService.MotivatorResultDeleteAllExecute(r)
}

/*
MotivatorResultDeleteAll Deletes all results on a motivator for the user

This endpoint deletes **all** results on the motivator with the ID specified for a given motivator for the currently authenticated user.

- On success it returns a `204 No content` response without a body.

- If the motivator with the ID does not exists a `404 Not Found` response is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param motivatorId The ID of the motivator to fetch users results
 @return ApiMotivatorResultDeleteAllRequest
*/
func (a *MotivatorServiceApiService) MotivatorResultDeleteAll(ctx context.Context, motivatorId int32) ApiMotivatorResultDeleteAllRequest {
	return ApiMotivatorResultDeleteAllRequest{
		ApiService: a,
		ctx: ctx,
		motivatorId: motivatorId,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) MotivatorResultDeleteAllExecute(r ApiMotivatorResultDeleteAllRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorResultDeleteAll")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator/{motivatorId}/result"
	localVarPath = strings.Replace(localVarPath, "{"+"motivatorId"+"}", url.PathEscape(parameterToString(r.motivatorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMotivatorSafetyNetAddRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	safetyNetItemContent *SafetyNetItemContent
}

func (r ApiMotivatorSafetyNetAddRequest) SafetyNetItemContent(safetyNetItemContent SafetyNetItemContent) ApiMotivatorSafetyNetAddRequest {
	r.safetyNetItemContent = &safetyNetItemContent
	return r
}

func (r ApiMotivatorSafetyNetAddRequest) Execute() (*SafetyNetItem, *http.Response, error) {
	return r.ApiService.MotivatorSafetyNetAddExecute(r)
}

/*
MotivatorSafetyNetAdd Add safety net item to currently authenticated user safety net.

Add safety net item to currently authenticated user safety net.

If the item was added to the users safety net, a `201 Created` response, with the created Item in the body (this contains an `id`).

If the validation if the requests body fails, a `422 Unprocessable Entity` error is returned, with an error message in the body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMotivatorSafetyNetAddRequest
*/
func (a *MotivatorServiceApiService) MotivatorSafetyNetAdd(ctx context.Context) ApiMotivatorSafetyNetAddRequest {
	return ApiMotivatorSafetyNetAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SafetyNetItem
func (a *MotivatorServiceApiService) MotivatorSafetyNetAddExecute(r ApiMotivatorSafetyNetAddRequest) (*SafetyNetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SafetyNetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorSafetyNetAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/safetyNet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.safetyNetItemContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MotivatorValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMotivatorSafetyNetDeleteRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	safetyNetItemId int32
}

func (r ApiMotivatorSafetyNetDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.MotivatorSafetyNetDeleteExecute(r)
}

/*
MotivatorSafetyNetDelete Deletes an item from users safety net

This endpoint deletes an item with the specified `id` from the currently authenticated users safety net.

- If the deletion was successful, a `204 No Content` response without body is returned.

- If there is no safety net item with the given `id` for the current user, it returns a `404 Not Found` response

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safetyNetItemId
 @return ApiMotivatorSafetyNetDeleteRequest
*/
func (a *MotivatorServiceApiService) MotivatorSafetyNetDelete(ctx context.Context, safetyNetItemId int32) ApiMotivatorSafetyNetDeleteRequest {
	return ApiMotivatorSafetyNetDeleteRequest{
		ApiService: a,
		ctx: ctx,
		safetyNetItemId: safetyNetItemId,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) MotivatorSafetyNetDeleteExecute(r ApiMotivatorSafetyNetDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorSafetyNetDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/safetyNet/{safetyNetItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"safetyNetItemId"+"}", url.PathEscape(parameterToString(r.safetyNetItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMotivatorSafetyNetGetRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
}

func (r ApiMotivatorSafetyNetGetRequest) Execute() ([]SafetyNetItem, *http.Response, error) {
	return r.ApiService.MotivatorSafetyNetGetExecute(r)
}

/*
MotivatorSafetyNetGet Get safety net for the current user

This endpoint returns the current users safety net. A safetyNet is an an array of items. How the safety net items are displayed in the UI is left to the user. 

This endpoint is associated with the motivator service, as it's implemented as a motivator exercise internally. However, the safety net motivator is shown in the `GET /motivator` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMotivatorSafetyNetGetRequest
*/
func (a *MotivatorServiceApiService) MotivatorSafetyNetGet(ctx context.Context) ApiMotivatorSafetyNetGetRequest {
	return ApiMotivatorSafetyNetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SafetyNetItem
func (a *MotivatorServiceApiService) MotivatorSafetyNetGetExecute(r ApiMotivatorSafetyNetGetRequest) ([]SafetyNetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SafetyNetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorSafetyNetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/safetyNet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMotivatorSafetyNetReplaceRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	safetyNetItemId int32
	safetyNetItemContent *SafetyNetItemContent
}

func (r ApiMotivatorSafetyNetReplaceRequest) SafetyNetItemContent(safetyNetItemContent SafetyNetItemContent) ApiMotivatorSafetyNetReplaceRequest {
	r.safetyNetItemContent = &safetyNetItemContent
	return r
}

func (r ApiMotivatorSafetyNetReplaceRequest) Execute() (*SafetyNetItem, *http.Response, error) {
	return r.ApiService.MotivatorSafetyNetReplaceExecute(r)
}

/*
MotivatorSafetyNetReplace Replaces a safety net item with a new one

This endpoint replaces the item with the provided `safetyNetItemId` with the data provided in the request body.

On successful replacement, a `200 OK` reponse is returned, with the new record provided in the reponse body.

If the deletion was successful, a `204 No Content` response without body is returned.

If the validation if the requests body fails, a `422 Unprocessable Entity` error is returned, with an error message in the body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safetyNetItemId
 @return ApiMotivatorSafetyNetReplaceRequest
*/
func (a *MotivatorServiceApiService) MotivatorSafetyNetReplace(ctx context.Context, safetyNetItemId int32) ApiMotivatorSafetyNetReplaceRequest {
	return ApiMotivatorSafetyNetReplaceRequest{
		ApiService: a,
		ctx: ctx,
		safetyNetItemId: safetyNetItemId,
	}
}

// Execute executes the request
//  @return SafetyNetItem
func (a *MotivatorServiceApiService) MotivatorSafetyNetReplaceExecute(r ApiMotivatorSafetyNetReplaceRequest) (*SafetyNetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SafetyNetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.MotivatorSafetyNetReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/safetyNet/{safetyNetItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"safetyNetItemId"+"}", url.PathEscape(parameterToString(r.safetyNetItemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.safetyNetItemContent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MotivatorValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
