/*
Kopfsachen

Kopfsachen e. V. is an association for the promotion of young people's mental health. The goal is to teach the basics of mental health literacy in various educational formats.

API version: 1.0.2
Contact: mail@kopfsachen.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// WikiServiceApiService WikiServiceApi service
type WikiServiceApiService service

type ApiWikiCreateEntryRequest struct {
	ctx context.Context
	ApiService *WikiServiceApiService
	createEntryBody *CreateEntryBody
}

func (r ApiWikiCreateEntryRequest) CreateEntryBody(createEntryBody CreateEntryBody) ApiWikiCreateEntryRequest {
	r.createEntryBody = &createEntryBody
	return r
}

func (r ApiWikiCreateEntryRequest) Execute() (*WikiEntry, *http.Response, error) {
	return r.ApiService.WikiCreateEntryExecute(r)
}

/*
WikiCreateEntry Add new wiki entries

Add wiki entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiCreateEntryRequest
*/
func (a *WikiServiceApiService) WikiCreateEntry(ctx context.Context) ApiWikiCreateEntryRequest {
	return ApiWikiCreateEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WikiEntry
func (a *WikiServiceApiService) WikiCreateEntryExecute(r ApiWikiCreateEntryRequest) (*WikiEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WikiEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiServiceApiService.WikiCreateEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/wiki"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createEntryBody == nil {
		return localVarReturnValue, nil, reportError("createEntryBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEntryBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiDeleteEntryRequest struct {
	ctx context.Context
	ApiService *WikiServiceApiService
	articleId string
}

func (r ApiWikiDeleteEntryRequest) Execute() (*http.Response, error) {
	return r.ApiService.WikiDeleteEntryExecute(r)
}

/*
WikiDeleteEntry Delete wiki entry by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param articleId ID of a wiki entry
 @return ApiWikiDeleteEntryRequest
*/
func (a *WikiServiceApiService) WikiDeleteEntry(ctx context.Context, articleId string) ApiWikiDeleteEntryRequest {
	return ApiWikiDeleteEntryRequest{
		ApiService: a,
		ctx: ctx,
		articleId: articleId,
	}
}

// Execute executes the request
func (a *WikiServiceApiService) WikiDeleteEntryExecute(r ApiWikiDeleteEntryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiServiceApiService.WikiDeleteEntry")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/wiki/{articleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"articleId"+"}", url.PathEscape(parameterToString(r.articleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.articleId) < 24 {
		return nil, reportError("articleId must have at least 24 elements")
	}
	if strlen(r.articleId) > 24 {
		return nil, reportError("articleId must have less than 24 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWikiGetRequest struct {
	ctx context.Context
	ApiService *WikiServiceApiService
	articleId string
}

func (r ApiWikiGetRequest) Execute() (*WikiEntry, *http.Response, error) {
	return r.ApiService.WikiGetExecute(r)
}

/*
WikiGet Fetch single wiki entry

This article can be used to fetch a single wiki entry.

It is not implemented yet and therefore marked as deprecated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param articleId ID of a wiki entry
 @return ApiWikiGetRequest

Deprecated
*/
func (a *WikiServiceApiService) WikiGet(ctx context.Context, articleId string) ApiWikiGetRequest {
	return ApiWikiGetRequest{
		ApiService: a,
		ctx: ctx,
		articleId: articleId,
	}
}

// Execute executes the request
//  @return WikiEntry
// Deprecated
func (a *WikiServiceApiService) WikiGetExecute(r ApiWikiGetRequest) (*WikiEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WikiEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiServiceApiService.WikiGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki/{articleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"articleId"+"}", url.PathEscape(parameterToString(r.articleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.articleId) < 24 {
		return localVarReturnValue, nil, reportError("articleId must have at least 24 elements")
	}
	if strlen(r.articleId) > 24 {
		return localVarReturnValue, nil, reportError("articleId must have less than 24 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWikiListRequest struct {
	ctx context.Context
	ApiService *WikiServiceApiService
	query *string
	limit *int32
	offset *int32
	withContent *bool
}

func (r ApiWikiListRequest) Query(query string) ApiWikiListRequest {
	r.query = &query
	return r
}

// The maximum number of articles the response will include (Use together with &#x60;offset&#x60; for api pagination).
func (r ApiWikiListRequest) Limit(limit int32) ApiWikiListRequest {
	r.limit = &limit
	return r
}

// The number of articles that will we skipped in response (Use together wuth &#x60;limit&#x60; for api pagination).
func (r ApiWikiListRequest) Offset(offset int32) ApiWikiListRequest {
	r.offset = &offset
	return r
}

// If the with content attribute is not &#x60;true&#x60;, the response will not return the content of wiki articles, but only the title and metadata attributes.  *Note*: This behaviour is not implemented yet, but It will be later. This endpoint can be used to download an index of all articles, without having to download the article content. The metadata might also contain a &#x60;preview&#x60; field with the first few character of each article in a later persion of the spec.   As adding the parameter later would be a breaking spec, always send the with_content parameter if you actually want to fetch article contents.
func (r ApiWikiListRequest) WithContent(withContent bool) ApiWikiListRequest {
	r.withContent = &withContent
	return r
}

func (r ApiWikiListRequest) Execute() (*WikiList200Response, *http.Response, error) {
	return r.ApiService.WikiListExecute(r)
}

/*
WikiList Fetch wiki entries

This endpoint returns a list of multiple wiki entries. 

You can use the `query` parameter to perform a fulltext search on `title` and `content`.

By default max. 20 WikiEntrys will be in the response. To fetch more, it's recommended to perform multiple queries (API Pagination). Use the `limit` and `offset` parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWikiListRequest
*/
func (a *WikiServiceApiService) WikiList(ctx context.Context) ApiWikiListRequest {
	return ApiWikiListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WikiList200Response
func (a *WikiServiceApiService) WikiListExecute(r ApiWikiListRequest) (*WikiList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WikiList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WikiServiceApiService.WikiList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wiki"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.withContent != nil {
		localVarQueryParams.Add("with_content", parameterToString(*r.withContent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError2
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
