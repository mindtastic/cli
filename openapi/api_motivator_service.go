/*
Kopfsachen

Kopfsachen e. V. is an association for the promotion of young people's mental health. The goal is to teach the basics of mental health literacy in various educational formats.

API version: 0.2
Contact: mail@kopfsachen.org
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MotivatorServiceApiService MotivatorServiceApi service
type MotivatorServiceApiService service

type ApiDeleteMotivatorUserIdRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
}

func (r ApiDeleteMotivatorUserIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMotivatorUserIdExecute(r)
}

/*
DeleteMotivatorUserId Delete a motivator from user's motivators.

Delete a motivator from user's motivators.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteMotivatorUserIdRequest
*/
func (a *MotivatorServiceApiService) DeleteMotivatorUserId(ctx context.Context) ApiDeleteMotivatorUserIdRequest {
	return ApiDeleteMotivatorUserIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) DeleteMotivatorUserIdExecute(r ApiDeleteMotivatorUserIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.DeleteMotivatorUserId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteMotivatorUserIdResultMotivatorIdRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	motivatorId int32
}

func (r ApiDeleteMotivatorUserIdResultMotivatorIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMotivatorUserIdResultMotivatorIdExecute(r)
}

/*
DeleteMotivatorUserIdResultMotivatorId Delete result from user's current motivator by timestamp.

Delete result from user's current motivator by timestamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param motivatorId The ID of the motivator to fetch users results
 @return ApiDeleteMotivatorUserIdResultMotivatorIdRequest
*/
func (a *MotivatorServiceApiService) DeleteMotivatorUserIdResultMotivatorId(ctx context.Context, motivatorId int32) ApiDeleteMotivatorUserIdResultMotivatorIdRequest {
	return ApiDeleteMotivatorUserIdResultMotivatorIdRequest{
		ApiService: a,
		ctx: ctx,
		motivatorId: motivatorId,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) DeleteMotivatorUserIdResultMotivatorIdExecute(r ApiDeleteMotivatorUserIdResultMotivatorIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.DeleteMotivatorUserIdResultMotivatorId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator/result/{motivatorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"motivatorId"+"}", url.PathEscape(parameterToString(r.motivatorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetMotivatorUserIdRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
}

func (r ApiGetMotivatorUserIdRequest) Execute() ([]GetMotivatorUserId200ResponseInner, *http.Response, error) {
	return r.ApiService.GetMotivatorUserIdExecute(r)
}

/*
GetMotivatorUserId Get current motivators by userId.

Get current motivators by userId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMotivatorUserIdRequest
*/
func (a *MotivatorServiceApiService) GetMotivatorUserId(ctx context.Context) ApiGetMotivatorUserIdRequest {
	return ApiGetMotivatorUserIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetMotivatorUserId200ResponseInner
func (a *MotivatorServiceApiService) GetMotivatorUserIdExecute(r ApiGetMotivatorUserIdRequest) ([]GetMotivatorUserId200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetMotivatorUserId200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.GetMotivatorUserId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSafetynetRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
}

func (r ApiGetSafetynetRequest) Execute() ([]SafetyNetItem, *http.Response, error) {
	return r.ApiService.GetSafetynetExecute(r)
}

/*
GetSafetynet Get currently authenticated users safety-net

Get currently authenticated users safety-net

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSafetynetRequest
*/
func (a *MotivatorServiceApiService) GetSafetynet(ctx context.Context) ApiGetSafetynetRequest {
	return ApiGetSafetynetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SafetyNetItem
func (a *MotivatorServiceApiService) GetSafetynetExecute(r ApiGetSafetynetRequest) ([]SafetyNetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SafetyNetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.GetSafetynet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/safetyNet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostMotivatorUserIdRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	motivator *Motivator
}

func (r ApiPostMotivatorUserIdRequest) Motivator(motivator Motivator) ApiPostMotivatorUserIdRequest {
	r.motivator = &motivator
	return r
}

func (r ApiPostMotivatorUserIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostMotivatorUserIdExecute(r)
}

/*
PostMotivatorUserId Add motivator to user's motivators.

Add motivator to user's motivators.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostMotivatorUserIdRequest
*/
func (a *MotivatorServiceApiService) PostMotivatorUserId(ctx context.Context) ApiPostMotivatorUserIdRequest {
	return ApiPostMotivatorUserIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) PostMotivatorUserIdExecute(r ApiPostMotivatorUserIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.PostMotivatorUserId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.motivator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostMotivatorUserIdFeedbackMotivatorIdRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	motivatorId int32
	motivatorResult *MotivatorResult
}

func (r ApiPostMotivatorUserIdFeedbackMotivatorIdRequest) MotivatorResult(motivatorResult MotivatorResult) ApiPostMotivatorUserIdFeedbackMotivatorIdRequest {
	r.motivatorResult = &motivatorResult
	return r
}

func (r ApiPostMotivatorUserIdFeedbackMotivatorIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostMotivatorUserIdFeedbackMotivatorIdExecute(r)
}

/*
PostMotivatorUserIdFeedbackMotivatorId Add a new result to user's current motivator.

Add a new result to user's current motivator.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param motivatorId The ID of the motivator to fetch users results
 @return ApiPostMotivatorUserIdFeedbackMotivatorIdRequest
*/
func (a *MotivatorServiceApiService) PostMotivatorUserIdFeedbackMotivatorId(ctx context.Context, motivatorId int32) ApiPostMotivatorUserIdFeedbackMotivatorIdRequest {
	return ApiPostMotivatorUserIdFeedbackMotivatorIdRequest{
		ApiService: a,
		ctx: ctx,
		motivatorId: motivatorId,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) PostMotivatorUserIdFeedbackMotivatorIdExecute(r ApiPostMotivatorUserIdFeedbackMotivatorIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.PostMotivatorUserIdFeedbackMotivatorId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/motivator/result/{motivatorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"motivatorId"+"}", url.PathEscape(parameterToString(r.motivatorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.motivatorResult
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSafetyNetPostRequest struct {
	ctx context.Context
	ApiService *MotivatorServiceApiService
	safetyNetItem *SafetyNetItem
}

func (r ApiSafetyNetPostRequest) SafetyNetItem(safetyNetItem SafetyNetItem) ApiSafetyNetPostRequest {
	r.safetyNetItem = &safetyNetItem
	return r
}

func (r ApiSafetyNetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.SafetyNetPostExecute(r)
}

/*
SafetyNetPost Add safety net item to currently authenticated user safety net.

Add safety net item to currently authenticated user safety net.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSafetyNetPostRequest
*/
func (a *MotivatorServiceApiService) SafetyNetPost(ctx context.Context) ApiSafetyNetPostRequest {
	return ApiSafetyNetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MotivatorServiceApiService) SafetyNetPostExecute(r ApiSafetyNetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MotivatorServiceApiService.SafetyNetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/safetyNet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.safetyNetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
